import { Meta } from '@storybook/addon-docs/blocks'

<Meta title="Документация/Договоренности по оформлению кода" />

# Договоренности по оформлению кода

## Оформление директории компонента
Директория с компонентом должна называться так же, как и сам компонент. Директория как правило содержит файлы `index.tsx`, `index.css` и `index.stories.tsx`. Если компонент содержит дочерние компоненты, то их следует размещать в директории `components` в данной директории. Тесты должны находиться в поддиректории `__tests__`.

Название файла с тестами должно соответсвовать названию файла с тестируемым модулем плюс суфикс `.test.`:

```
index.tsx -> index.test.tsx
classname.ts -> classname.test.ts
```

Каждый публичный компонент должен быть описан в storybook.

Примерная структура компонента:

```
SomeComponent/
    __stories__/
      SomeComponent.stories.tsx
      SomeComponent.mdx
    __tests__/
      SomeComponent.test.tsx
    SomeComponent.tsx
    SomeComponent.css
    index.tsx
```

Кроме того мы используем function component, соответсвенно для его реализации нужно использовать `arrow function`, и тип `React.FunctionComponent<T>`:

```typescript
const SomeComp: React.FC<SomeCompProps> = ({ prop1, prop2 }) => {

}
```

В большинстве случаев лучше декомпозировать пропсы прямо в аргументах функции. Если же декомпоизция слишком громоздкая, то можно вынести декомпоизцию в тело функции

## Разбивка компонента
Если вы собираетесь разбить компонент на более мелкие сущности, то нужно придерживаться следующих правил:
1. Он (компонент) должен лежать в папке с дочерними компонентами (не быть в том же файле)
2. У него должен быть отдельный бэм-класс


## Использование enums
Ипользовать enum следует для объявления публичных или общих "перечислимых" типов. Если ваш тип предполагает использование вне компонента, то следует его объявить через enum. Например:

```typescript
enum Statuses {
  Normal = 'normal',
  Danger = 'danger',
  Warning = 'warning',
}
```

Это позволит переиспользовать этот тип во внешних компонентах (если их будут реализовывать сторонние разработчики). Не обязательно явно указывать значения enum, как в случае выше, но это может быть удобным, если вам нужно конкретное значение enum (чтобы избежать дополнительного парсинга значений)

Если тип конкретного компонента должен принимать только одно значение из enum, то можно делать так:

```typescript
type ComponentProps = {
  status: Statuses.Normal
}
```

Или несколько значений:

```typescript
type ComponentProps = {
  status: Statuses.Normal | Statuses.Danger
}
```

Вместо enum для определения перечислимых типов можно использовать такой способ:

```typescript
export const statuses = ['normal', 'danger', 'warning'] as const;
type Status = typeof statuses[number];
```

Его следует использовать в случае, если тип уникален для компонента, или если этот тип не публичен

## Наименование boolean-методов и констант для сохранения значения
Наименование boolean-методов для проверки на существование чего-либо нужно начинать с приставки `is` (`isDays()`, `isZooming()`, `isSomthing()`). Если вы хотите сохранить возвращаемое значение в переменную, то нужно переменную называть так же, как название метода, а импортируемому методу добавить приставку `get`:

```
import { isDays as getIsDays } from 'utils/time'

const isDays = getIsDays(data)
```

## Type vs Interface
Стоит использовать `type` (не `interface`) для объявления props, да и для любых других типов. `interface` стоит использовать тогда, когда вы описываете общий тип, который где-то нужно имплементировать. Интерфейсы хорошо подходят для написания абстрактного кода, который не работает с конкретными типами или экземлярами, а ожидает получить любую сущность, реализующего заданный интерфейс. Подробноее по type vs interface можно почитать [здесь](https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c)

## Default Props
Не стоит использовать defaultProps в function component, вместо этого нужно использовать значения по умолчанию при деструктуризации props:

```typescript
const SomeComp: React.FC<SomeCompProps> = ({ someValue = 'defaultValue' }) => {

}
```

## Комментарии к типам
Для описания полей типа нужно оставлять многострочный комментарий. Это необходимо для верной генерации документации. Пример:

```typescript
type DateProps = {
  /** Текущий день строительства скважины */
  currentDay?: number;
  /** Плановое время строительства (сутки) */
  planDaysCount?: number;
};
```

## Стилизация switch конструкций
Поскольку в eslint нет такого правила, то договорились, что в switch все конструкции case нужно обрамлять фигурными скобками:
```js
// Хорошо
switch (value) {
  case 'top': {
    // ...
    return ''
  }
}

// Плохо
switch (value) {
  case 'top':
    return ''
}
```

## Использование formatLabel и unit
При разработке нового компонента или доработке существующего, надо учитывать
как лучше добавлять форматирование подписей и значений, а как указывать общие
единицы измерения, для этого есть несколько правил:

* если надо указать общие единицы измерения отдельно от данных, например на
осях линейного графика, тогда лучше добавить `props` вида `unit`;
* если надо указать единицы измерения рядом с данными, как например в тултипе,
то лучше добавить `props` с функцией форматирования подписей или значений;

## Порядок сущностей внутри *.ts(x) файлов
```typescript
    // 1. Импорты
    import React from 'React'

    // 2. Типы
    type Data = [...]

    type Props = {
        data: Data
    }

    // 3. Типы + константы, из которых они выводятся
    export const sizes = ['s', 'm'] as const
    type Size = typeof sizes[number]

    // 4. Константы
    const MAX_WIDTH = 100

    // 5. Функции
    const getTransformData = (data: Data): [] => ...

    // 6. Дочерние компоненты
    const ListItem: React.FC<{}> = (props) => ...

    // 7. Компонент
    export const Component: React.FC<Props> = ({ data }) => {
        const items = getTransformData(data)

        return <ul>{items.map(item => <ListItem {...item} />)}</ul>
    }
```

## Оформление render props
Render props должен возвращать тип `React.ReactElement | null`

Пример:
```typescript
type Props = {
  renderItem: () => React.ReactElement | null
}
```
